#!/usr/bin/env php
<?php

use Laravel\Octane\RequestContext;
use Laravel\Octane\Swoole\Handlers\OnManagerStart;
use Laravel\Octane\Swoole\Handlers\OnServerStart;
use Laravel\Octane\Swoole\Handlers\OnWorkerStart;
use Laravel\Octane\Swoole\Handlers\OnWorkerStop;
use Laravel\Octane\Swoole\ServerStateFile;
use Laravel\Octane\Swoole\SwooleExtension;
use Laravel\Octane\Swoole\WorkerState;
use Laravel\Octane\Swoole\Coroutine\Context;
use Laravel\Octane\Swoole\Coroutine\Monitor;
use Swoole\Coroutine;
use Swoole\Http\Server;
use Swoole\Timer;

ini_set('display_errors', 'stderr');

require_once __DIR__.'/../src/Stream.php';

require __DIR__.'/../fixes/fix-symfony-dd.php';

$bootstrap = fn ($serverState) => require __DIR__.'/bootstrap.php';

/*
|--------------------------------------------------------------------------
| Create The Swoole Server
|--------------------------------------------------------------------------
|
| First, we will load the server state file from disk. This file contains
| various information we need to boot Swoole such as the configuration
| and application name. We can use this data to start up our server.
|
*/

$serverState = json_decode(file_get_contents(
    $serverStateFile = $_SERVER['argv'][1]
), true)['state'];

$server = require __DIR__.'/createSwooleServer.php';

$timerTable = require __DIR__.'/createSwooleTimerTable.php';

/*
|--------------------------------------------------------------------------
| Handle Server & Manager Start
|--------------------------------------------------------------------------
|
| The following callbacks manage the master process and manager process
| start events. These handlers primarily are responsible for writing
| the process ID to the server state file so we can remember them.
|
*/

$server->on('start', fn (Server $server) => $bootstrap($serverState) && (new OnServerStart(
    new ServerStateFile($serverStateFile),
    new SwooleExtension,
    $serverState['appName'],
    $serverState['octaneConfig']['max_execution_time'] ?? 0,
    $timerTable,
    $serverState['octaneConfig']['tick'] ?? true
))($server));

$server->on('managerstart', function () use ($serverState) {
    // Don't bootstrap entire application before server / worker start. Otherwise, files can't be gracefully reloaded... #632
    require_once __DIR__.'/../src/Swoole/Handlers/OnManagerStart.php';
    require_once __DIR__.'/../src/Swoole/SwooleExtension.php';

    (new OnManagerStart(
         new SwooleExtension, $serverState['appName']
    ))();
});

/*
|--------------------------------------------------------------------------
| Handle Worker Start
|--------------------------------------------------------------------------
|
| Swoole will start multiple worker processes and the following callback
| will handle their state events. When a worker starts we will create
| a new Octane worker and inform it to start handling our requests.
|
| We will also create a "workerState" variable which will maintain state
| and allow us to access the worker and client from the callback that
| will handle incoming requests. Basically this works like a cache.
|
*/

require_once __DIR__.'/WorkerState.php';

$workerState = new WorkerState;

$workerState->cacheTable = require __DIR__.'/createSwooleCacheTable.php';
$workerState->timerTable = $timerTable;
$workerState->tables = require __DIR__.'/createSwooleTables.php';

/*
|--------------------------------------------------------------------------
| Stats Tables (Shared Memory)
|--------------------------------------------------------------------------
| Two Swoole Tables for per-worker stats collection:
| - $statsCounters: atomic incr/decr for request counts
| - $statsSnapshots: periodic set() for coroutine/pool state
| Controlled via SWOOLE_STATS_ENABLED env var.
*/

// Read SWOOLE_STATS_ENABLED from .env (before Laravel bootstrap)
$swooleStatsEnabled = false;
$envPath = isset($serverState['publicPath']) ? dirname($serverState['publicPath']) . '/.env' : '';
if ($envPath && file_exists($envPath)) {
    $envContent = file_get_contents($envPath);
    if (preg_match('/^SWOOLE_STATS_ENABLED\s*=\s*(.+)$/m', $envContent, $m)) {
        $swooleStatsEnabled = filter_var(trim($m[1]), FILTER_VALIDATE_BOOLEAN);
    }
}

$statsCounters = new \Swoole\Table(64);
$statsCounters->column('requests_active', \Swoole\Table::TYPE_INT);
$statsCounters->column('requests_total', \Swoole\Table::TYPE_INT);
$statsCounters->create();

$statsSnapshots = new \Swoole\Table(64);
$statsSnapshots->column('worker_id', \Swoole\Table::TYPE_INT);
$statsSnapshots->column('pid', \Swoole\Table::TYPE_INT);
$statsSnapshots->column('coroutine_num', \Swoole\Table::TYPE_INT);
$statsSnapshots->column('pool_current', \Swoole\Table::TYPE_INT);
$statsSnapshots->column('pool_available', \Swoole\Table::TYPE_INT);
$statsSnapshots->column('pool_max', \Swoole\Table::TYPE_INT);
$statsSnapshots->column('updated_at', \Swoole\Table::TYPE_FLOAT, 8);
$statsSnapshots->create();

$server->on('workerstart', fn (Server $server, $workerId) =>
    (function (string $basePath) use ($server, $workerId, $serverState, $workerState, $timerTable, $swooleStatsEnabled, $statsCounters, $statsSnapshots) {
        $handler = new OnWorkerStart(
            new SwooleExtension,
            $basePath,
            $serverState,
            $workerState
        );

        $handler($server, $workerId);

        // Stats collection timer (per-worker, every 500ms)
        if ($swooleStatsEnabled && ! ($workerId >= ($server->setting['worker_num'] ?? 1))) {
            $wid = (string) $workerId;

            // Initialize counter row
            $statsCounters->set($wid, ['requests_active' => 0, 'requests_total' => 0]);

            // Snapshot timer — updates coroutine/pool stats
            Timer::tick(500, function () use ($statsSnapshots, $workerState, $wid) {
                $poolStats = $workerState->workerPool?->stats() ?? [];
                $coStats = Coroutine::stats();
                $statsSnapshots->set($wid, [
                    'worker_id'      => $workerState->workerId ?? 0,
                    'pid'            => $workerState->workerPid ?? 0,
                    'coroutine_num'  => $coStats['coroutine_num'] ?? 0,
                    'pool_current'   => $poolStats['current_size'] ?? 0,
                    'pool_available' => $poolStats['available'] ?? 0,
                    'pool_max'       => $poolStats['max_size'] ?? 0,
                    'updated_at'     => microtime(true),
                ]);
            });

            // Worker 0: aggregate stats logger (every 1s)
            if ($workerId === 0) {
                $logPath = ($serverState['publicPath'] ?? '/var/www/reactive-1.businesspress.dev/public');
                $logPath = dirname($logPath) . '/storage/logs/swoole-stats.log';

                Timer::tick(1000, function () use ($server, $statsCounters, $statsSnapshots, $logPath) {
                    $serverStats = $server->stats();
                    $workers = [];
                    $totalActive = 0;
                    $totalCoroutines = 0;
                    $totalPoolCurrent = 0;
                    $totalPoolAvailable = 0;

                    foreach ($statsSnapshots as $wid => $snap) {
                        $counters = $statsCounters->get($wid) ?: ['requests_active' => 0, 'requests_total' => 0];
                        $workers[] = [
                            'wid'            => (int) $wid,
                            'active'         => $counters['requests_active'],
                            'total'          => $counters['requests_total'],
                            'coroutines'     => $snap['coroutine_num'],
                            'pool_cur'       => $snap['pool_current'],
                            'pool_avail'     => $snap['pool_available'],
                            'pool_max'       => $snap['pool_max'],
                        ];
                        $totalActive += $counters['requests_active'];
                        $totalCoroutines += $snap['coroutine_num'];
                        $totalPoolCurrent += $snap['pool_current'];
                        $totalPoolAvailable += $snap['pool_available'];
                    }

                    $entry = [
                        'ts'                  => date('H:i:s'),
                        'conn_num'            => $serverStats['connection_num'] ?? 0,
                        'idle_workers'        => $serverStats['idle_worker_num'] ?? 0,
                        'total_active'        => $totalActive,
                        'total_coroutines'    => $totalCoroutines,
                        'total_pool_current'  => $totalPoolCurrent,
                        'total_pool_available' => $totalPoolAvailable,
                        'request_count'       => $serverStats['request_count'] ?? 0,
                        'dispatch_count'      => $serverStats['dispatch_count'] ?? 0,
                        'workers'             => $workers,
                    ];

                    @file_put_contents($logPath, json_encode($entry) . "\n", FILE_APPEND);
                });
            }
        }
    })($bootstrap($serverState))
);

/*
|--------------------------------------------------------------------------
| Handle Incoming Requests
|--------------------------------------------------------------------------
|
| The following callback will handle all incoming requests plus send them
| the worker. The worker will send the request through the application
| and ask the client to send the response back to the Swoole server.
|
*/

$server->on('request', function ($request, $response) use ($server, $workerState, $serverState, $swooleStatsEnabled, $statsCounters, $statsSnapshots) {
    $appDebug = filter_var($_ENV['APP_DEBUG'] ?? getenv('APP_DEBUG') ?: false, FILTER_VALIDATE_BOOLEAN);

    // STATS: Short-circuit /swoole-stats endpoint (bypasses pool/Laravel entirely)
    if ($swooleStatsEnabled && ($request->server['request_uri'] ?? '') === '/swoole-stats') {
        $serverStats = $server->stats();
        $workers = [];
        $summary = ['total_active' => 0, 'total_coroutines' => 0, 'total_pool_current' => 0, 'total_pool_available' => 0];

        foreach ($statsSnapshots as $wid => $snap) {
            $counters = $statsCounters->get($wid) ?: ['requests_active' => 0, 'requests_total' => 0];
            $row = array_merge($snap, $counters);
            $workers[] = $row;
            $summary['total_active'] += $counters['requests_active'];
            $summary['total_coroutines'] += $snap['coroutine_num'];
            $summary['total_pool_current'] += $snap['pool_current'];
            $summary['total_pool_available'] += $snap['pool_available'];
        }

        $response->header('Content-Type', 'application/json');
        $response->end(json_encode([
            'server'  => $serverStats,
            'summary' => $summary,
            'workers' => $workers,
        ], JSON_PRETTY_PRINT));
        return;
    }

    $requestStartTime = microtime(true);

    // STATS: Track request start
    $wid = $swooleStatsEnabled ? (string) ($workerState->workerId ?? 0) : null;
    if ($wid !== null) {
        $statsCounters->incr($wid, 'requests_active', 1);
        $statsCounters->incr($wid, 'requests_total', 1);
    }

    // PROFILER: Initialize timeline at the earliest possible point
    $profiling = \App\Profiling\RequestTimeline::begin();

    // Wait for worker to be fully initialized
    while (! ($workerState->ready ?? false)) {
        usleep(10000); // 10ms
    }

    // Get a worker from the pool with a timeout (Queuing mechanism)
    $worker = null;

    if ($workerState->clientPool) {
        $poolConfig = $serverState['octaneConfig']['swoole']['pool'] ?? [];
        $waitTimeout = $poolConfig['wait_timeout'] ?? 30.0;
        $rejectOnFull = $poolConfig['reject_on_full'] ?? false;
        $overloadStatus = $poolConfig['overload_status'] ?? 503;
        $retryAfter = $poolConfig['overload_retry_after'] ?? 5;

        if (!is_numeric($waitTimeout)) {
            $waitTimeout = 30.0;
        }

        $waitTimeout = (float) $waitTimeout;

        try {
            if ($workerState->workerPool) {
                $worker = $workerState->workerPool->acquire((float) $waitTimeout, (bool) $rejectOnFull);
            } else {
                $worker = $workerState->clientPool->pop(0.001);

                if ($worker === false && ! $rejectOnFull && $waitTimeout > 0) {
                    $worker = $workerState->clientPool->pop((float) $waitTimeout);
                }
            }
        } catch (\Throwable $e) {
            error_log("[ACQUIRE_ERR] " . $e->getMessage());
            $worker = null;
        }

        // PROFILER: Mark pool acquisition time
        if ($profiling) {
            \App\Profiling\RequestTimeline::mark('pool_acquired');
        }

        if (! $worker) {
            // Pool exhausted — send 503
            if ($response->isWritable()) {
                $response->status((int) $overloadStatus);
                $response->header('Content-Type', 'application/json');
                if (is_numeric($retryAfter) && (int) $retryAfter > 0) {
                    $response->header('Retry-After', (string) $retryAfter);
                }
                $body = ['error' => 'Service Unavailable'];
                if ($appDebug) {
                    $poolStats = $workerState->workerPool ? $workerState->workerPool->stats() : [];
                    $body['debug'] = ['pool_stats' => $poolStats];
                }
                try {
                    $response->end(json_encode($body));
                } catch (\Throwable $e) {
                    // ignore
                }
            }
            return;
        }
    } else {
        // Fallback if pool not initialized
        $worker = $workerState->worker;
        // PROFILER: No pool — mark immediately
        if ($profiling) {
            \App\Profiling\RequestTimeline::mark('pool_acquired');
        }
    }

    $cid = Coroutine::getCid();
    $context = Coroutine::getContext();
    $context['worker'] = $worker;
    $context['worker_id'] = $workerState->workerId;
    $context['request_start_time'] = $requestStartTime;

    Monitor::registerRequestCoroutine($cid);

    if ($workerState->timerTable) {
        $workerState->timerTable->set($cid, [
            'worker_pid' => $workerState->workerPid,
            'time' => time(),
            'fd' => $request->fd,
        ]);
    }

    try {
        $marshaledArgs = $worker->getClient()->marshalRequest(new RequestContext([
            'swooleRequest' => $request,
            'swooleResponse' => $response,
            'publicPath' => $serverState['publicPath'],
            'octaneConfig' => $serverState['octaneConfig'],
        ]));

        // PROFILER: Mark after request marshaling
        if ($profiling) {
            \App\Profiling\RequestTimeline::mark('request_marshaled');
        }

        $worker->handle(...$marshaledArgs);
    } catch (\Throwable $e) {
        error_log("[HANDLE_ERR] " . get_class($e) . ": {$e->getMessage()} at {$e->getFile()}:{$e->getLine()}");

        // Send 500 error response if not already sent
        if ($response->isWritable()) {
            try {
                $response->status(500);
                $response->header('Content-Type', 'application/json');
                $body = ['error' => 'Internal Server Error'];
                if ($appDebug) {
                    $body['debug'] = [
                        'exception' => $e->getMessage(),
                        'file' => $e->getFile() . ':' . $e->getLine(),
                    ];
                }
                $response->end(json_encode($body));
            } catch (\Throwable $responseError) {
                // ignore
            }
        }
    } finally {
        // STATS: Track request end
        if ($wid !== null) {
            $statsCounters->decr($wid, 'requests_active', 1);
        }

        $cid = Coroutine::getCid();

        if ($workerState->timerTable) {
            $workerState->timerTable->del($cid);
        }

        Monitor::unregisterRequestCoroutine($cid);

        // Return worker to the pool
        if ($workerState->workerPool && $worker) {
            try {
                $kept = $workerState->workerPool->release($worker);
            } catch (\Throwable $e) {
                $kept = false;
            }

            if (! $kept) {
                $worker->terminate();
            }
        } elseif ($workerState->clientPool && $worker) {
            $workerState->clientPool->push($worker, 0.001);
        }

        Context::clear();
    }
});

/*
|--------------------------------------------------------------------------
| Handle Tasks
|--------------------------------------------------------------------------
|
| Swoole tasks can be used to offload concurrent work onto a group of
| background processes which handle the work in isolation and with
| separate application state. We should handle these tasks below.
|
*/

$server->on('task', fn (Server $server, int $taskId, int $fromWorkerId, $data) =>
    $workerState->worker
        ? ($data === 'octane-tick'
            ? $workerState->worker->handleTick()
            : $workerState->worker->handleTask($data))
        : null
);

$server->on('finish', fn (Server $server, int $taskId, $result) => $result);

/*
|--------------------------------------------------------------------------
| Handle Worker & Server Shutdown
|--------------------------------------------------------------------------
|
| The following callbacks handle the master and worker shutdown events so
| we can clean up any state, including the server state file. An event
| will be dispatched by the worker so the developer can take action.
|
*/

$server->on('workerstop', function ($server, $workerId) use ($workerState, $serverState) {
    (new OnWorkerStop(
        $serverState['octaneConfig']['swoole']['shutdown_timeout'] ?? 30
    ))($server, $workerId);

    if ($workerState->tickTimerId) {
        Timer::clear($workerState->tickTimerId);
    }

    if ($workerState->worker) {
        $workerState->worker->terminate();
    }
});

$server->start();
