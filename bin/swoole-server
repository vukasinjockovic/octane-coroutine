#!/usr/bin/env php
<?php

use Laravel\Octane\RequestContext;
use Laravel\Octane\Swoole\Handlers\OnManagerStart;
use Laravel\Octane\Swoole\Handlers\OnServerStart;
use Laravel\Octane\Swoole\Handlers\OnWorkerStart;
use Laravel\Octane\Swoole\Handlers\OnWorkerStop;
use Laravel\Octane\Swoole\ServerStateFile;
use Laravel\Octane\Swoole\SwooleExtension;
use Laravel\Octane\Swoole\WorkerState;
use Laravel\Octane\Swoole\Coroutine\Context;
use Laravel\Octane\Swoole\Coroutine\Monitor;
use Swoole\Coroutine;
use Swoole\Http\Server;
use Swoole\Timer;

ini_set('display_errors', 'stderr');

require_once __DIR__.'/../src/Stream.php';

require __DIR__.'/../fixes/fix-symfony-dd.php';

$bootstrap = fn ($serverState) => require __DIR__.'/bootstrap.php';

/*
|--------------------------------------------------------------------------
| Create The Swoole Server
|--------------------------------------------------------------------------
|
| First, we will load the server state file from disk. This file contains
| various information we need to boot Swoole such as the configuration
| and application name. We can use this data to start up our server.
|
*/

$serverState = json_decode(file_get_contents(
    $serverStateFile = $_SERVER['argv'][1]
), true)['state'];

$server = require __DIR__.'/createSwooleServer.php';

$timerTable = require __DIR__.'/createSwooleTimerTable.php';

/*
|--------------------------------------------------------------------------
| Handle Server & Manager Start
|--------------------------------------------------------------------------
|
| The following callbacks manage the master process and manager process
| start events. These handlers primarily are responsible for writing
| the process ID to the server state file so we can remember them.
|
*/

$server->on('start', fn (Server $server) => $bootstrap($serverState) && (new OnServerStart(
    new ServerStateFile($serverStateFile),
    new SwooleExtension,
    $serverState['appName'],
    $serverState['octaneConfig']['max_execution_time'] ?? 0,
    $timerTable,
    $serverState['octaneConfig']['tick'] ?? true
))($server));

$server->on('managerstart', function () use ($serverState) {
    // Don't bootstrap entire application before server / worker start. Otherwise, files can't be gracefully reloaded... #632
    require_once __DIR__.'/../src/Swoole/Handlers/OnManagerStart.php';
    require_once __DIR__.'/../src/Swoole/SwooleExtension.php';

    (new OnManagerStart(
         new SwooleExtension, $serverState['appName']
    ))();
});

/*
|--------------------------------------------------------------------------
| Handle Worker Start
|--------------------------------------------------------------------------
|
| Swoole will start multiple worker processes and the following callback
| will handle their state events. When a worker starts we will create
| a new Octane worker and inform it to start handling our requests.
|
| We will also create a "workerState" variable which will maintain state
| and allow us to access the worker and client from the callback that
| will handle incoming requests. Basically this works like a cache.
|
*/

require_once __DIR__.'/WorkerState.php';

$workerState = new WorkerState;

$workerState->cacheTable = require __DIR__.'/createSwooleCacheTable.php';
$workerState->timerTable = $timerTable;
$workerState->tables = require __DIR__.'/createSwooleTables.php';

$server->on('workerstart', fn (Server $server, $workerId) =>
    (function (string $basePath) use ($server, $workerId, $serverState, $workerState) {
        $handler = new OnWorkerStart(
            new SwooleExtension,
            $basePath,
            $serverState,
            $workerState
        );

        $handler($server, $workerId);
    })($bootstrap($serverState))
);

/*
|--------------------------------------------------------------------------
| Handle Incoming Requests
|--------------------------------------------------------------------------
|
| The following callback will handle all incoming requests plus send them
| the worker. The worker will send the request through the application
| and ask the client to send the response back to the Swoole server.
|
*/

$server->on('request', function ($request, $response) use ($server, $workerState, $serverState) {
    // FIX (Bug #8): Store request start time in coroutine context, not global state
    // This prevents metrics corruption when multiple concurrent requests run
    $requestStartTime = microtime(true);

    // Wait for worker to be fully initialized
    while (! ($workerState->ready ?? false)) {
        usleep(10000); // 10ms
    }

    // Get a worker from the pool with a timeout (Queuing mechanism)
    $worker = null;
    if ($workerState->clientPool) {
        $poolConfig = $serverState['octaneConfig']['swoole']['pool'] ?? [];
        $waitTimeout = $poolConfig['wait_timeout'] ?? 30.0;
        $rejectOnFull = $poolConfig['reject_on_full'] ?? false;
        $overloadStatus = $poolConfig['overload_status'] ?? 503;
        $retryAfter = $poolConfig['overload_retry_after'] ?? 5;

        if (!is_numeric($waitTimeout)) {
            $waitTimeout = 30.0;
        }

        $waitTimeout = (float) $waitTimeout;
        try {
            if ($workerState->workerPool) {
                $worker = $workerState->workerPool->acquire((float) $waitTimeout, (bool) $rejectOnFull);
            } else {
                $worker = $workerState->clientPool->pop(0.001);

                if ($worker === false && ! $rejectOnFull && $waitTimeout > 0) {
                    $worker = $workerState->clientPool->pop((float) $waitTimeout);
                }
            }
        } catch (\Throwable $e) {
            error_log("❌ Failed to acquire worker from pool: " . $e->getMessage());
            $worker = null;
        }

        if (! $worker) {
            $errCode = $workerState->clientPool->errCode;
            error_log("❌ Pool pop failed! ErrCode: {$errCode}, Stats: " . json_encode($workerState->clientPool->stats()));

            // Timeout occurred - pool is exhausted and queue is full/slow
            $response->status((int) $overloadStatus);
            $response->header('Content-Type', 'application/json');
            if (is_numeric($retryAfter) && (int) $retryAfter > 0) {
                $response->header('Retry-After', (string) $retryAfter);
            }
            $response->end(json_encode([
                'error' => 'Service Unavailable',
                'message' => 'Server is too busy, please try again later',
                'debug_pool_stats' => $workerState->clientPool->stats(),
                'debug_err_code' => $errCode,
                'debug_worker_pool' => $workerState->workerPool ? $workerState->workerPool->stats() : null,
            ]));
            return;
        }
    } else {
        // Fallback if pool not initialized (shouldn't happen with new OnWorkerStart)
        $worker = $workerState->worker;
    }

    $cid = Coroutine::getCid();
    $context = Coroutine::getContext();
    $context['worker'] = $worker;
    $context['worker_id'] = $workerState->workerId;
    $context['request_start_time'] = $requestStartTime; // FIX (Bug #8)

    // FIX (Bug #9): Register this coroutine as handling a request
    Monitor::registerRequestCoroutine($cid);

    if ($workerState->timerTable) {
        // FIX (Bug #4): Add error handling for timer table set operation
        $cid = Coroutine::getCid();
        $setResult = $workerState->timerTable->set($cid, [
            'worker_pid' => $workerState->workerPid,
            'time' => time(),
            'fd' => $request->fd,
        ]);

        if (!$setResult) {
            error_log("⚠️ Timer table full! Could not track coroutine #{$cid}. Consider increasing max_timer_table_size.");
        }
    }

    try {
        $worker->handle(...$worker->getClient()->marshalRequest(new RequestContext([
            'swooleRequest' => $request,
            'swooleResponse' => $response,
            'publicPath' => $serverState['publicPath'],
            'octaneConfig' => $serverState['octaneConfig'],
        ])));
    } catch (\Throwable $e) {
        // CRITICAL FIX: Catch all exceptions to prevent worker crashes
        // Log the error and send a 500 response instead of crashing
        error_log("❌ CRITICAL ERROR in Worker #{$workerState->workerId} (Coroutine #" . Coroutine::getCid() . "): " . $e->getMessage());
        error_log("   File: {$e->getFile()}:{$e->getLine()}");
        
        // Send 500 error response if not already sent
        if (!$response->isWritable()) {
            error_log("   Response already sent, cannot send error response");
        } else {
            try {
                $response->status(500);
                $response->header('Content-Type', 'application/json');
                $response->end(json_encode([
                    'error' => 'Internal Server Error',
                    'message' => (isset($serverState['octaneConfig']['app']['debug']) && $serverState['octaneConfig']['app']['debug'])
                        ? $e->getMessage()
                        : 'An error occurred while processing your request',
                    'worker_id' => $workerState->workerId,
                    'coroutine_id' => Coroutine::getCid(),
                ]));
            } catch (\Throwable $responseError) {
                error_log("   Failed to send error response: " . $responseError->getMessage());
            }
        }
        
        // Worker continues! Don't crash, just handle the next request
    } finally {
        $cid = Coroutine::getCid();

        if ($workerState->timerTable) {
            $workerState->timerTable->del($cid);
        }

        // FIX (Bug #9): Unregister this request coroutine
        Monitor::unregisterRequestCoroutine($cid);

        // CRITICAL FIX: Return worker to the pool!
        if ($workerState->workerPool && $worker) {
            try {
                $kept = $workerState->workerPool->release($worker);
            } catch (\Throwable $e) {
                $kept = false;
                error_log('⚠️ Worker pool release failed - terminating worker: '.$e->getMessage());
            }

            if (! $kept) {
                $worker->terminate();
            }
        } elseif ($workerState->clientPool && $worker) {
            $workerState->clientPool->push($worker, 0.001);
        }

        // Ensure coroutine context is cleared (Swoole does this automatically, but explicit is safe)
        Context::clear();
    }
});

/*
|--------------------------------------------------------------------------
| Handle Tasks
|--------------------------------------------------------------------------
|
| Swoole tasks can be used to offload concurrent work onto a group of
| background processes which handle the work in isolation and with
| separate application state. We should handle these tasks below.
|
*/

$server->on('task', fn (Server $server, int $taskId, int $fromWorkerId, $data) =>
    $workerState->worker 
        ? ($data === 'octane-tick'
            ? $workerState->worker->handleTick()
            : $workerState->worker->handleTask($data))
        : null
);

$server->on('finish', fn (Server $server, int $taskId, $result) => $result);

/*
|--------------------------------------------------------------------------
| Handle Worker & Server Shutdown
|--------------------------------------------------------------------------
|
| The following callbacks handle the master and worker shutdown events so
| we can clean up any state, including the server state file. An event
| will be dispatched by the worker so the developer can take action.
|
*/

$server->on('workerstop', function ($server, $workerId) use ($workerState, $serverState) {
    // Use the new graceful shutdown handler
    (new OnWorkerStop(
        $serverState['octaneConfig']['swoole']['shutdown_timeout'] ?? 30
    ))($server, $workerId);

    if ($workerState->tickTimerId) {
        Timer::clear($workerState->tickTimerId);
    }

    if ($workerState->worker) {
        $workerState->worker->terminate();
    }
});

$server->start();
